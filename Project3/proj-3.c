#include <stdio.h>
#include <unistd.h> // Used for sleep()
#include "sem.h"

int buffer_size = 0;
int iteration_limit = 0; // number of times producers and consumers run their while loop
int producers = 0;
int consumers = 0;


int *buffer = 0;
int in, out = 0;
Semaphore *full;
Semaphore *empty;


void producer(int id)
{
    for(int i = 1; i <= iteration_limit; i++) 
    {
        while (buffer[in] != 0) {
            P(empty);
        }

            printf("\n Producer %d is producing item number %d \n\n", RunQ->thread_id, i);
            buffer[in] = RunQ->thread_id;
            in = (in + 1) % buffer_size;
        V(full);

        if (i == iteration_limit && id == RunQ->thread_id) {
            TCB_t *current = DelQueue(&RunQ);
            swapcontext(&(current->context), &(RunQ->context));
        } else {
            yield();
        }
        
    }
}

void consumer(int id)
{
    for(int i = 1; i <= iteration_limit; i++) 
    {
        while (buffer[out] == 0) {
            P(full);
        }
            
        printf("\n Consumer %d is consuming item generated by Producer %d \n\n", -(RunQ->thread_id), buffer[out]);
        buffer[out] = 0;
        out = (out + 1) % buffer_size;

        V(empty);
        if (i == iteration_limit && id == RunQ->thread_id) {
            TCB_t *current = DelQueue(&RunQ);
            swapcontext(&(current->context), &(RunQ->context));
        } else {
            yield();
        }
    }
}

int main()
{

    scanf("%d,%d,%d,%d", &buffer_size, &producers, &consumers, &iteration_limit);

    buffer = (int*) malloc(buffer_size * sizeof(int));
	full = malloc(sizeof(Semaphore));
	empty = malloc(sizeof(Semaphore));
    initSem(full, 0); 
    initSem(empty, buffer_size);
    InitQueue(&RunQ);
    // Initialize buffer
    for (int i = 0; i < buffer_size; i++) {
        buffer[i] = 0;
    }

    for(int i = 0; i < producers+consumers; i++) {
        int id;
        scanf("%d", &id);
        if(id > 0) {
            start_thread(producer, id);
        } else {
            start_thread(consumer, id);
        }
    }

    /*start_thread(consumer, -1);
    start_thread(consumer, -2);
    start_thread(consumer, -3);
    start_thread(consumer, -4);*/

    run();

    return 0;
}